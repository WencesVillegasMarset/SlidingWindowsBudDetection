import pandas as pd
import matplotlib.pyplot as plt
import os
import cv2
import numpy as np
import argparse

def run(args):

    csv_path = args.csv

    per_sample_csv = pd.read_csv(csv_path)
    model_foldername = per_sample_csv['model_name'].values[0] 
    model_threshold = per_sample_csv['threshold'].values[0]
    
    out = pd.cut(per_sample_csv['true_positive_norm_distance'].values, bins=[0,0.2,0.4,0.6,0.8,1,1.5,2,4,8,16], include_lowest=True)
    out.value_counts().plot.bar(rot=0, color="b", figsize=(12,6))
    plt.title([str(out.value_counts().values[i]) for i in range(out.value_counts().values.shape[0])])
    plt.xlabel('Normalized Distance of the true positive cluster')
    plt.ylabel('Number of samples')
    plt.savefig(os.path.join('.', 'output', model_foldername, str(model_threshold) + model_foldername +'valid_plot.png'))


    true_positives = per_sample_csv.loc[per_sample_csv['buds_predicted']>=1,:].shape[0]
    false_positives = per_sample_csv['buds_predicted'].sum() - true_positives
    precision = (true_positives / (true_positives + false_positives))

    true_positives = per_sample_csv.loc[per_sample_csv['buds_predicted']>=1,:].shape[0]
    false_negatives = per_sample_csv.loc[per_sample_csv['buds_predicted']==0,:].shape[0] # aquellos en los que no se predijeron ninguna
    recall = (true_positives / (true_positives + false_negatives))

    valid_csv = pd.DataFrame({
        'precision': [precision],
        'recall': [recall]
    })
    valid_csv.to_csv(os.path.join('.', 'output', model_foldername, str(model_threshold) + model_foldername + 'valid_csv.csv'))




def main():
    parser = argparse.ArgumentParser(
        description="Run metric report for sliding windows clustered masks")
    parser.add_argument("-csv", help="csv containing the report generated by dbscan.py",
                        dest="csv", type=str, required=True)

    parser.set_defaults(func=run)

    args = parser.parse_args()

    if (not os.path.exists(args.csv)):
        parser.error('Invalid path to csv')
    
    args.func(args)


if __name__ == "__main__":
    main()